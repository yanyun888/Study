
数据采集系统DMS
Data Mining System

关注这个项目的设计方法
#一，项目背景
#二，项目流程
##1. 需求分析
1. 按照软件工程的要求，用分析设计人员所能够理解的技术语言复述用户提出的业务需求，同时用用户
所能够理解的业务语言，反馈分析设计人员的技术要求。
2. 按照分析和设计的要求对用户的需求进行分析、归纳、抽象和必要的扬弃。
3. 用例，时间流，异常流，前置条件，后置条件
4. 《需求规则说明书》
5. 演示demo

##2，概要设计
面向过程的框架设计：时间流
现象对象的框架设计：由对象和对象间协作
核心任务：找对象
读取登陆日志文件，形成匹配日记记录

根据需求中的事件找对象，事件由对象触发，责任分配，关注行为 -- 接口驱动
- 日志文件读取器对象->读取
- 日志记录生成器对象->形成
根据需求中的数据找对象，关注属性 -- 模型驱动
- 日志文件 - 被读取
- 日志记录 - 被形成

根据需求中的异常流找对对象，关注各种错误 -- 异常驱动
《概要设计》
《开发计划》
《测试计划》
+ UML统一建模语言

##3.详细设计
1. 将对象抽象为类，形成类图
2. 对类分配责任，即主要成员函数
3. 时序图
4. 成员变量主要来自前置条件，后置条件，中间变量
5. 成员函数需要明确函数名，返回值，参数表，常属性，访控属性，异常说明；
6. 成员函数的具体过程，活动图，
7. 其他细节：构造函数、析构函数、拷贝构造、拷贝赋值、操作符号重载
8. 引入继承和多态提高代码的复用性、抽象性和解耦能力
9. 套用设计模式，要以适用性为前提
《详细设计》

##4. 编写代码/编写测试用例
##5. 测试、修改、验证
##6. 产品发布/工程实施
##7. 项目总结


#三、数据采集客户机
1. 用例描述
数据采集客户机备份并读取登陆日志文件，形成匹配日志记录，通过网络发送给数据采集服务器。
/var/adm/wtmpx
2. 参与者
系统管理员、数据采集客户机、
绘制用例图
3. 基本事件流
1)登陆日志的备份(wtmpx)，产生备份文件，以系统时间为后缀（wtmpx.20150923171623），同时清空原始登陆日志。
2)读取备份文件，产生登入登出记录：
登陆名，登陆IP，登陆进程PID，登入登出的时间
3)匹配登入登出记录，形成匹配日志记录：
登陆名、登陆IP，登陆进程PID，登入时间、登出时间，登录时段
4)根据数据采集服务器的IP地址和端口号，向其发起连接请求，建立TCP连接
5)将匹配日志记录发送给数据采集服务器
4. 异常事件流
1)备份登陆日志失败，终止采集，
2)读取备份文件失败，终止采集，
3)在匹配的过程中发现某些记录只有登陆没有登出信息，存入一个登陆文件，以备下次采集时继续匹配；
    有些记录只有登出信息没有登陆信息直接丢弃。
4)连接数据采集服务器失败，将全部匹配的日志记录存入发送失败文件，以备下次采集重发。
5)发送过程中失败了，将尚未发送的匹配日志记录存入发送失败文件，以备下次采集重发

5. 前置条件
1) 日志文件的位置： /var/

最小依赖原则


#四、数据采集服务器
##1. 用例描述
数据采集服务器通过网络接收数据采集客户机上传的匹配日志记录，保存到数据库中。
##2. 参与者
系统管理员、数据采集服务器、服务器套接字、客户线程，日志队列、存储线程、数据访问对象
**消息队列的流量控制**

##3. 基本事件流
1) 接收匹配日志记录
- 建立服务器监听套接字
- 等待并接受客户机的连接请求
- 为发起连接的客户机建立客户线程，接受该客户机上传的匹配日志记录
- 将客户机接收到的匹配日志记录压入日志队列
2) 保存匹配日志记录
- 创建一个存储线程
- 创建数据访问对象DAO(data access object),建立和数据库的连接
- 监视日志队列，一旦发现其中包含未处理的匹配日志记录，即从中弹出该记录
- 将从日志队列弹出的匹配日志记录通过数据访问对象存入数据库
- 销毁数据访问对象，关闭与数据库的连接，释放相关资源。



条件变量 - 生产者 - 消费着模型。
生产者：产生数据的线程
消费者：消耗数据哦县城，如存储线程
条件变量可以让调用线程在满足特定条件的情况建立停-等机制，以避免出现撑死或饿死的情况

```lang=c
//创建并初始化条件变量
pthread_cond_t = PHTEAD_COND_INITIALIZER;
int pthread_cond_init(pthread_cond_t* cond,pthread_condattr_t const* attr);

//等待条件变量
int pthread_cond_wait(pthread_cond_t* cond,pthread_mutex_t* mutex);

//调用线程首先会释放互斥锁，然后进入休眠状态，知道有其他线程想cond条件变量发送信号，才能被唤醒，在其重新获得mutex互斥锁之后，从该函数返回，继续运行。

//向cond条件变量发送信号，在该条件变量中睡眠的若干县城总
pthrea_cond_signal(pthread_cond_t& cond);

//销毁条件变量
int pthread_cond_destory(pthread_cond_t* cond);


int pthread_cond_broadcast(pthread_cond_t* cond);
向cond条件变量发送信号，在该条件变量中睡眠的所有线程都会被唤醒，但只有重获得互斥的那个线程才会
```
```
编程模型：
       主线程：创建并初始化环境变量
    /	                       \
  生产者	                  消费者
  if(缓存区满)				if(缓存区空)
  \                             /
  线程：销毁条件边变量
```

##4. 异常事件流
1) 访问数据库失败，终止采集
2) 网络通信失败，终止采集
3) 创建线程失败，终止采集

##5. 前置条件
1) 用于套接字保定的IP地址和端口号
2) 数据库的用户名和口令

##6. 后置条件
数据库中的匹配日志记录

##7. 类图
线程的封装
```language
void* run (void* arg){ //线程过程函数
 //线程任务处理...
}
pthread_create(...,run,...);
```

静态成员函数与全局函数的区别 -> 访问控制属性
？有没有静态虚函数： 貌似是没有的，没有this指针，没有对象

```language
class Thread{
public:
	void start(void){
    	pthread_create();
    }
}
```

全局变量的创建时间在主线程之前

TCP 在传输中要注意单次收集，可能会有收不全的情况。
DGRAM 数据报文

#五、定时自动运行数据采集客户机
编写数据采集客户机启动脚本client.sh，将工作目录切换到数据采集

crontab -e

A B C D E
A - 分钟 `[0.59]`
B - 小时 `[0,23]`
C - 天   `[1,31]`
D - 月   `[1,12]`
E - 星期 `[0,6]` 0 表示星期日
`*` 通配置符号
在指定的时间约束下，自动执行`<命令行>`
`15 * * * 1-5 <命令行1>` 在周一到周五，每个小时的一刻种的时候执行

有关开发模式的问题
CMMI 认证
瀑布流程模型
敏捷开发
cristal 水晶
xp 敏捷开发

#六、项目总结
1. 基于UML统一建模语言的面向对象设计技术；
2. C/C++语言的编程拘束；
3. shell脚本编程技术；
4. Liunx/Unix操作系统编程技术；
5. 基于`Pro*C`的Oracle数据库编程技术；
6. 基于Socket的网络编程技术；
7. 基于POSIX的多线程和线程同步技术；
8. 基于Qt的图形用户界面(GUI)编程；
9. STL标准模板库技术；


