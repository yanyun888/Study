

protected 保护 - 只有自己和自己的子类可以访问

类初始化的两中语法规则
Stu s("张飞",25,356654);
Stu s = Stu("张飞",25,356654);

执行构造函数体代码是整个构造过程的最后一步，这保证了构造函数体代码所依赖的一切资
源和先决条件。
在该代码被执行时已经准备充分。

构造函数
构造函数定义
缺省构造函数(无参构造函数)
如果一个类中没有定义构造函数，系统会提供一个无参构造函数，使成员变量获得定义，对
于基本数据类型不初始化，
对于类类型的成员变量，用相应类型的无参构造函数初始化。
如果定义了构造函数，无论是否有参数，系统都不会再提供无参构造函数。


使用缺省值能够减少构造函数的重载版本。

无参构造函数并不一定真的无参，只是能以无参的方式调用。

有时必须为类提供缺省构造，因为他可能做为另一个类的字对象而被缺省构造。

若字对象不宜缺省构造，则需要为父对象提供缺省构造函数，并显式地以非缺省方式构造该子对象。

##类型转换构造函数(单参构造函数)

class 类名/目标类型{
    类名/目标类型 (const 原类型& src){ ... }
}

用explicit修饰构造函数，可以强制这样的构造函数实现的类型转换必须显示的进行。


##拷贝构造函数
从一个已定义的对象构造同类型的副本，就是拷贝构造。
    class 类名{
        类名(const 类名& that) {}
    }
* 如果你个类没有定义拷贝构造函数，那么编译器会为其提供一个缺省拷贝构造函数。对于基本类
型的成员变量，按字节复制，对类类型和成员变量，调用相应类型的拷贝构造函数。

* 如果自定义了拷贝构造函数，编译器不再提供缺省拷贝构造函数，这是如果实现 类类型成员 的
复制，会默认使用该
类的缺省构造来构造子对象。这是如果想实现一个复制的操作，必须在自定义的拷贝构造函数中编
码完成。

如果B定义了拷贝构造，可以定义初始化表，显式的说明用that.初始化，这是也会调用A的拷贝构
造，否则使用A的缺省
构造来构造`m_a`子对象。

* 拷贝构造函数的调用时机：
用已定义的对象作为同类型对象的构造实参
以对象的形式向函数传递参数。
某些拷贝过程会因编译器的优化而被省略，如果是g++编译器，可以加-fno-elide-constructors选
项禁止优化。

初始化表，自己的类管自己的事，所以最好不要在自己的类中操作其他类的成员数据。

#缺省拷贝构造函数的缺陷
特殊情况下，编译器提供的缺省拷贝构造函数可能无法满足要求，这时就必须通过自定义拷贝构造函数

缺省构造，无参构造，拷贝构造。
类中自定义的构造函数          系统提供构造函数
 不提供任何构造函数          缺省构造，拷贝构造
   自定义缺省构造                拷贝构造
  自定义了拷贝构造                 无        ----- 注意此条
 自定义了缺省构造和拷贝            无


- ?无参构造、有参构造、拷贝构造之间的区别


