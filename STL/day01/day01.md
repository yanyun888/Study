
#STL day01
[TOC]
##一、模板起源
- C/C++语言的强类型约束性，保证效率和类型安全；同时妨碍程序设计者编写通用的数据结构和算法。
- (带参数的宏) 宏定义没有类型的约束，可以编写通用的数据结构和算法，但同时也引入类型不安全的风险
- 通过宏定义一个通用于不同数据类型函数样板，利用预处理器自动生成针对不同类型的具体函数，这样既保证了算法和数据结构的一般性，同行死又可以确保类型安全。

把预处理

强类型和弱类型/泛型编程思想

##二、函数模板
### 1. 定义
```
template<typename 类型形参1,typename 类型形参2,...>
返回类型 函数模板名字(调用形参表){ 函数体 }
```
例如
```language
template<typename A,typename b,typename _C>
A function (b arg){
  _C var;
  ...
}
```
### 2. 使用
`函数模板名<类型实参1,类型实参2,...>`l
例如
`char ret = function<char,int,string>(123)`
通过具体的类型实参经将函数模板编译为具体函数的过程，通常被称为实例化

### 3.要求
任何类型(无论是基本类型还是类类型)都可以用于实例化一个函数模板，但是该类型必须满足模板对于类型参数的要求。

### 4. 二次编译
-  C++编译器对普通函数通常只编译一次，即生成二进制形式的机器指令代码；
但对函数模板则至少要编译两次：
- 第一次是在编译器“看到”函数模板本身时，做与类型参数无关的语法检查，如果通过则生成关于该模板的每部表示，
- 第二次是在编译器“看到”调用该函数模板时，用所提供的类型实参，与之前获得的内部表示中的类型一一结合，做与类型相关的语法检查，如果通过则生成针对具体函数的实例的二进制代码。

### 5.隐式推断
+ (在调用函数模板时，可以省略模板的参数名字)
如果函数模板调用参数(圆括号里的参数)的类型相关于该模板的模板参数(尖括号里的参数)，那么在调用该函数模板时，即使不显示制定模板参数，编译器也可以根据调用函数的类型隐式推断出正确的模板类型。
但是，有些时候编译器隐式推断出的类型可能并非程序编写者所期望的类型，导致结果错误，需要注意。

**注意：**
只有参数可以进行隐式推断
隐式推断不能和隐式转换同时发生











