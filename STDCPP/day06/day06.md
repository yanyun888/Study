
拷贝构造和拷贝赋值
1 拷贝构造
  如果一个类包含指针形式的成员变量，系统会提供缺省拷贝构造函数，只是复制了指针变量的本身，这种拷贝方式称为浅拷贝。
   浅拷贝将导致不同对象间的数据共享，所以会在析够函数引发“double free”错误，为此就需要自定义拷贝构造函数，实现深拷贝。
2 拷贝赋值
  1）防止自赋值
  2）释放旧资源
  3）分配新资源
  4）复制新的内存
  5）返回自引用

建议：
1）尽量避免使用指针的成员变量
2）尽量避免拷贝构造和拷贝赋值
3）如果拷贝构造支持深拷贝，那么拷贝赋值就也应该支持深拷贝

静态成员
C:static
1 静态成员变量
class 类名{
    static 数据类型 变量名;//声明
};
数据类型 类名::变量名=初值;//定义并初始化

2 静态成员函数
class 类名{
    static 成员函数；
};

3 单例模式
  保证一个类只有一个对象
  1）禁止在外部创建对象：私有化构造函数
  2）类自己维护唯一的对象：创建一个类 类型的静态成员变量
  3）提供访问该对象的方法：静态成员函数
  饿汉式：无论用或不用，程序运行时即创建
  懒汉式：用的时候即创建，不用时即销毁
两种单列模式的共同点：
- 为了保证每个类的唯一性，都需要私有化构造和拷贝构造函数；
- 都使用了静态成员变量来存放该类 单例 的本身或地址
- getInstance 都需要引用变量来接收
不同点:
- 饿汉模式：直接使用了静态成员变量来存放单例，在程序运行开始的时候就会存在
- 懒汉模式：使用静态成员变量来存放单例的指针，保存地址，在第一次使用的时候进行实例化
- 采用静态指针的懒汉模式，有释放实例的过程，releaseInstance函数要负责delete(释放内存)


成员变量指针:
1 定义
`类型 类名::*成员指针变量名 = &类名::成员变量`

2 使用
`对象.*成员指针变量名`
`".*"成员指针解引用运算符`
`对象指针->*成员指针变量名`
`"->*"间接成员指针解引用运算符`
  
成员函数指针
1 定义
`  返回类型(类名::*成员函数指针)(形参表) = &类名::成员函数名`
2 使用
`  (对象.*成员函数指针)(实参表);`
`  (对象指针->*成员函数指针)(实参表);`

操作符重载
复数：3+4i
两个复数相加：（3+4i + 1+3i）  = 4+7i;
一、双目运算符重载 L#R
    运算类的双目运算符: + - * /
    1 成员函数形式
    L#R的表达式会被编译器处理为: L.operator#(R)的成员函数调用，该函数返回值即为表达式的值。
    class LEFT{
    	const RESULT operator#(const RIGHT& right)const{
    		...
    	}
    };
    
    作业1：实现string类的拷贝构造和拷贝赋值
        class string{
        private:
        	char *m_s;
        };
  		1)实现构造函数，在初始化表中分配内存并初始化
  		2)实现析够函数，释放构造对象时的内存
    	3)实现深拷贝构造
    	4)实现深拷贝赋值
    	5)实现访问char*接口，返回一个char*即打印字符串值
    	string s1("123456")；
    	string s2(s1);//拷贝构造
    	string s3("abcdef");
    	s3 = s2;//拷贝赋值
    作业2：实现两个复数对象的减法操作
    	操作符重载（成员函数形式）
    

