从C到C++
类和对象
操作符重载
继承和多态
异常和IO流
《C++程序设计原理与实践》
《C++ primer》

<!-- MarkdownTOC -->

- [C++语言的概述](#c语言的概述)
    - [历史背景](#历史背景)
        - [C++的江湖地位](#c的江湖地位)
        - [C++之父，Bjarne Stroustrup](#c之父，bjarne-stroustrup)
        - [C与C++的比较](#c与c的比较)
- [第一个C++程序](#第一个c程序)
    - [编译方式](#编译方式)
    - [文件拓展名](#文件拓展名)
- [名字空间](#名字空间)
- [C++的结构体、联合体、枚举](#c的结构体、联合体、枚举)
- [C++的布尔类型](#c的布尔类型)
- [C++的运算符](#c的运算符)
- [C++的函数](#c的函数)
    - [1 重载](#1-重载)
    - [2 重载匹配](#2-重载匹配)
    - [为什么C++支持函数的重载](#为什么c支持函数的重载)

<!-- /MarkdownTOC -->


# C++语言的概述
## 历史背景
### C++的江湖地位
前5名：java、C、C++、C#、Python

### C++之父，Bjarne Stroustrup

1979 Cpre 为C语言增加了类似simula
1983 Bjarne发布了一个全新的编程语言，C with class，后来被命名为C++语言

### C与C++的比较
- C++增加了与多C语言没有的特性
 全面支持面向对象、操作符重载、异常处理、泛型编程
- C++相对C语言更适合大型软件的开发

# 第一个C++程序

## 编译方式
gcc xxx.cpp -lstdc++
g++ xxx.cpp

## 文件拓展名
.cpp(主流的文件后缀)/.cc/.C/.cxx
头文件
`include<stdio.h> //C 风格`
`include<cstdio>  //C++ 风格`

名字空间的概念
std是标准c++库中所有的函数、变量、对象的名字空间；
? 函数中的局部变量所在的是哪个名字空间

# 名字空间
定义名字空间
namespace 名字空间名{
    名字空间成员
}

访问名字空间的方法
1 通过作用域限定符 ::

2 名字空间名
无名名字空间：任何没有置于某个名字空间中的全局变量、函数等都处于无名名字空间
使用`::`标识符来使用无名名字控件里的内容。

# C++的结构体、联合体、枚举
1 结构体可以定义函数，称为成员函数，在成员函数中可以直接访问成员变量

和C语言的区别：
结构体中可以定义函数
当定义结构体类型变量是可以省略struct关键字的

2 联合体：可以定义匿名联合变量
union关键字使用时可以省略
支持匿名联合
```
union{
int a = 1;
char b = 'a';
};
```
3 枚举 是一个独立的数据类型
enum 关键字可以省略
是一种独立的数据类型，不能直接用整数进行赋值。
enum COLOR {RED,GREEN,BLUE};
c=100; //c语言 ok，c++ error
c=red; //c++ ok

COLOR func(void){
    return RED,GREEN,BLUE;
}

# C++的布尔类型
bool 专门用来表示逻辑值： true、false
bool 在内存占一个字节 1表示true 0表示false
bool 类型变量可以接受任意类型变量的表达式，其 值非0则为true ，0则为false。

表示逻辑假 0，NULL，0.0，'\0'

# C++的运算符
C++ 支持字符形式的运算符号
&& - and
|| - or
^  - xor
{  - <%
}  - %>
为了兼容小语种,所规定的替代写法

# C++的函数
## 1 重载
在相同作用域中可以定义同名的函数，但是他们的参数表必须有所区分，这样的函数构成重载关系。

## 2 重载匹配
调用函数时，编译将根据实参的匹配程序，自动选择匹配最优重载版本。
完全匹配>常量转换>升级转换>标准转换>省略号转换
常量转换：char* -> const char*
标准转换：double -> int
升级转换：char -> int

还有自定义类型

## 为什么C++支持函数的重载
使用nm命令察看.o文件
重载的原理：C++编译器是通过对函数换名，将参数表信息整合到函数名中，
解决重载函数的名字矛盾问题。
通过在函数声明中加入extern "c"，要求编译器不对函数名换名，方便C语言程序调
用该函数，但是这样的函数无法重载。

extern "C" 需要在h文件中加入，这样在cpp文件调用时由于编译器定义了`__cplusplus` 所以
会在cpp文件引用时包含extern "C"
而在c文件引用的时候忽略extern "C" ,C语言中是不支持extern "C"的。

使用宏定义解决不同语言的调用问题。



