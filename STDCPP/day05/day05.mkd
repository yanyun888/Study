
#STDCPP Day05
[TOC]
##初始化表

数组的初始化表只在C++2011支持

必须要使用初始化表的地方：
1. 如果有类 类型的成员变量，而该类有没有无参构造函数，则必须通过初始化表初始化该成员变量。
2. 如果成员变量是const修饰的 或 引用类型的成员变量 ，必须通过初始化表初始化该成员变量。

##this指针
###this指针的定义
每个类的构造函数和成员函数中都包含一个隐藏的该类 类型的指针函数，名字为this。该指针指向调用这个成员函数的对象，或者正在被构造的对象。
- 对于普通成员函数，this指针指向调用该函数的对象。
- 对于构造函数，this指针就是指向这个正在被构造的对象。

###this指针的作用
1. 区分作用域
this指针在构造函数中使用，可以区分构造函数中的形参和成员变量。
2. 从函数中返回调用对象自身，实现函数的级联调用。
3. 从类的内部销毁该对象自身 -- 对象自毁
4. 在类的内部访问调用对象自身(交叉类问题)
```
A a;
B b;
a.func(b.this);
//老师和学生的提问交互关系
```

##常对象 和 常函数
1 常对象
```
class A {}
const A a;  //a就是常对象
const A& r=a; // r引用常对象
const A* pa = &a ; // p指向常对象
```
2 常函数
在一个成员函数的参数后面加一个const，这个成员函数就成为常函数，其中相当于给this指针
加上const修饰
使其变成常指针，因此不能在常函数中修改成员变量的值，常函数只会出现在类的成员函数中(是
类中独有的一种函数类型)。
被mutable修饰的成员函数可以被常函数修改

常对象和普通对象的调用关系：
非常对象既可以调用非常函数也可以调用常函数，
但是如果是常对象只能调用常函数不能调用非常函数。

函数名和形参标相同的成员函数，其常版本和非常版本可以构成重载关系，
非常对象调用非常版本，常对象调用常版本，如果没有非常版本，那么我们的非常对象会调用常版本。

##析构函数
析构函数在每个类中只有一个，是类中特殊的成员函数。
语法:函数名必须是“~类名”，没有返回值也没有参数，不能被重载，一个类只能有一个析构函数。
class 类名{
    ~类名(void){ ...  }
}
当对象被销毁时，该对象的析构函数自动被调用，主要负责清理对象生命周期内*动态*产生的资源。
缺省的析构函数不会释放动态分配的内存。
栈对象当其离开作用域时，其析构函数被作用域终止花括号调用。
堆对象的析构函数被delete、delete[]调用
* 缺省构造函数：系统默认提供的构造函数
    对于基本成员变量，什么也不做。
    对于类 类型的成员变量，会调用相应类的析构函数。

* 对象被销毁的过程
调用析构函数
    -> 执行析构函数代码
    -> 执行类成员的析构函数代码
    -> 释放内存空间
注意比较构造和析构的顺序

* 析构函数调用的顺序
逆序调用类类型成员的析构函数，析构所有成员的子对象。
执行析构函数体代码是整个析构过程的第一步，这保证了析构函数体代码所以来的一切资源和先决条
件在该代码被执行尚且未被销毁，并保持析构前的状态。


