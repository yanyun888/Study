
_Cppday02notes_
#C++函数

##缺省参数
可以为函数的部分或者全部形参指定缺省值，调用该函数时，如果不给实参，就取缺省值作为相应的函数值，否则就取实参值。

void func(int a=1,int b=2){

}

int main(){
    func(10,20); //a=10,b=20
    func(10);  //a=10,b=2
    func();  //a=1,b=2
    return 0;
}

缺省值必须靠右边，如果有一个参数有缺省值，那么这个参数的右侧所有参数都必须有缺省值;
注意防止重载引起的歧义冲突，
如果函数的定义和声明分开，那么缺省参数就应该写在函数的声明部分，定义部分不写。

#哑元参数
 只有类型而没有名字的形参。
 1>重载运算符：前++ 后++
 2>为了兼容以前的代码

#内联函数
 使用inline关键字修饰的函数叫做内联函数
 多次调用的小而简单的函数适合内联
 如果调用次数少，或者大而复杂的
 递归函数不适合内联
 inline只是建议不是要求，能否内联是由编译器决定的，有些编译器不加inline关键字也会处理
 为内联的方式。
 使用内联函数


#动态内存分配
C语言：
`int *P = malloc(sizeof(int));`
`*p = 200;`
`free(p);`
C++:
`int *p = new int(100);`
`*p = 300;`
`delete p;`
 
`int* parr=new int[10];`
`parr[0] = 10;`
 
#C++的引用
引用就是别名
int a=10;
int& b=a; // b引用a，b就是a的引用
引用在定义时必须初始化，在定义过引用之后不能修改

int a=1,b=2,c=3;
(a=b)=c;//a=b 的结果保存在a中，是左值
前++返回左值，后++返回右值

(a+b)=c; //a+b 返回的是一个叫做匿名变量右值

将引用作为函数的参数可以修改实参变量的值，并减少函数调用的开销；避免了虚实结合过程
中实参值的复制。

强制类型转换
在函数的形式参数注意类还

const int& b = a; 常引用 引用对象的值不能修改(不能通过引用修改对象的值)

将函数的形参定义为为常引用，可以提高传参效率；
但是有可能意外修改实参的值，为了防止对实参的意外修改，需要加const进行修饰，同时还可
以接受常量型的实参。

const int& r 常引用既可以引用左值也可以引用右值，被称为是万能引用。
_C++11特性_ : 二级引用 int && r = func();
int& r = func(); //func返回值保存到匿名变量，是右值。

能够取地址的变量才是左值。

不要返回局部变量的引用,因为该引用所引用的内存会在函数返回以后随着函数栈一起被释放。
但是返回成员变量，静态变量，静态变量，全局变量的引用是可以的。


#引用和指针
* 引用的本质就是指针
* 指针可以不做初始化，其目标可以在初始化以后随意修改；而引用必须初始化，而一旦初始化，所引用的目标不能再改变。
* 可以定义指针的指针，但是不能定义 _引用的指针_ 。
`int a;`
`int* p = &a;`
`int& r = a;`
`int&* pr = &r;`

* 可以定义指针的引用,但是 不能 定义引用的引用(在C++11 前)
`int a;`
`int* p = &a;`
`int*& p = p;//ok`
 
* 可以定义指针数组，但是不能定义引用数组，可以定义数组的引用。
`int arr[3]={1,2,3};`
`int *parr = arr;`
`int &barr[3] = arr;//error`
`int (&rarr)[3] = arr;//ok`

`int a,b,c;`
`int *parr[]={&a,&b,&c};`
`int &rarr[]={a,b,c};`
 

