

子网掩码
用于判断两个IP地址的是否在同一个局域网中

网络字节序是大端字节序列

UDP/TCP

数据流
数据报

今天的内容

(1)TCP和UDP的比较
(2)基于UDP的通信模型
(3)多线程的基本概念和使用

1.tcp协议和udp协议的比较
1.1tcp协议
	tcp - 传输控制协议,面向连接的方式
	需要在通信中全程保持连接:建立连接->通信->关闭连接
优点：自动重发一些错误数据，保证了数据的安全性和完整性
	数据的接收方可以实时通知数据发送方进行数据流量的控制
缺点：
三次握手
	
udp - 用户数据报协议
优点：服务器的压力比较小，资源占用率比较低
缺点：不会自动重发一切错误数据，不保证数据的安全性和完整性
	数据的接收方不能实时通知发送方控制流量

2.基于UDP协议的通信模型(重点)
2.1通信模型
服务器：
(1)创建socket，使用socket函数
(2)准备通信地址，使用结构体类型
(3)绑定socket和通信地址，使用bind函数
(4)进行通信，使用
(5)关闭socket，使用close

客户端：
(1)创建socket，使用socket函数
(2)准备通信地址，使用服务器的地址
(3)进行通信，使用send/sendto/recv/recvfrom
(4)关闭socket，使用close


send 
ssize_t sendto(int sockfd,const void *buf,size_t len,int flags, );
第一个参数：socket描述符
第二个参数：被发送数据的首地址
第三个参数：被发送数据的大小
第四个参数：发送的标志，默认给0
第五个参数：目标地址
第六个参数：目标地址的大小
功能：给指定的地址发送指定的数据



recv(int sockfd,void* buf,size_t len,int flags);
ssize_t recvfrom(int sockfd,void* buf,size_t len,int flags,
		struct sockaddr* src_addr,socklen_t *addrlen);

第四个参数：接受标志位，默认为0
第五个参数：结构体指针，存放发送放方的通信地址
第六个参数：指针类型，
功能：主要用于接受指定的数据并记录发送方的通信地址，以便于回发消息

在以后的网络编程中使用send/sendto/recv/recvfrom

3.多线程的概念和使用
3.1基本概念
	线程 - 隶属于进程，是进程内部的程序流，主流的操作系统支持多线程，而每一个进程的内部又可以
支持多线程，多线程之间可以并行工作。

	进程是重量级单位，每个进程都需要独立的内存资源等，因此新建进程对资源的消耗比较大，当进程达
到一定数量时，会使得操作系统出现卡顿的现象。

	线程是轻量级单位，每个线程都共享躲在进程的内存资源等，因此新建线程对资源的消耗比较小，但是
每个线程也有自己独立的一块栈区(只是把进程栈区划分成许多小块，分给线程)。

	目前主流的开发都采用多线程技术


3.2 线程的创建
(1)pthread_create();
#include<pthread.h>
int pthread_create(pthread_t *thread,const pthread_attr_t *attr,
		void* (*start_routine )(void*), void * arg);
第一个参数：指针类型，存放线程号的地址
第二个参数：线程的属性，默认NULL
第三个参数：函数指针类型，表示线程的处理函数，
第四个参数：作为第三个参数的实参

返回值：成功返回0，失败返回错误编号

关于多线程之间的关系，
进程从中原来的线程，也就是main函数中的线程叫做主线程，使用pthread_create函数创建出来的线程叫做、
子线程；进程中必须要有主线程，另外进程中的多个线程之间相互独立，又相互影响，当主线程结束时，会
导致进程结束，而进程的结束又会导致所有线程结束。

pthread_t pthread_self(void);

编译链接时加-pthread选项

作业：
在main函数中使用malloc申请一个int类型大小的存储空间，由用户输入一个半径存放在该内存区域中，使用
pthread_create函数创建子线程，并且将半径的数值传给子线程，在子线程中计算圆形的周长和面积，并且
在子线程打印出来，主线程等待子线程结束后释放动态内存空间

明日预报：
(1) 多线程的处理
(2) 基于tcp的多人聊天室
