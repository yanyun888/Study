
##动态绑定：
当编译器看到通过指针或引用调用虚函数的语句时，不会生成有关函数调用的指令，而会用一段代码替代该语句，这段代码在运行时被执行，完成如下操作：
  1)确定调用指针或引用的真实类型(目标对象),从中找到虚指针；
  2)根据虚指针找到相应的虚表，并从中获取所调用虚函数的入口地址；
  3)根据虚函数的入口地址执行虚函数代码。
覆盖不是说的拿着子类的函数复制一份 把 基类的函数覆盖掉。 看虚指针指向哪个虚表。

##虚析构函数
1. delete一个指向子类对象的基类指针，实际被调用的仅仅是基类的析构函数，基类的析构函数只
   负责析构子类对象中的基类子对象，而不会调用子类的析构函数，这样子类中动态内存分配的资
   源就会形成内存泄露。
2. 如果将基类的析构函数声明为虚函数，那么子类的析构函数也就是一个虚函数，并且对子类的虚
   函数形成有效覆盖，表现出多态的特性。

##类中哪些函数可以设置为虚函数
构造函数 不可以虚
析构函数 可以虚
普通成员函数 可以虚
静态成员函数 不可以虚

##运行时的类型信息
1. typeid 运算符
 `include <typeinfo>`
- 可以用于作用于类型(基本类型 和 类类型) 或者 对象， 返回typeinfo类型对象的常引用。
 typeid(x).name()
- typeinfo类提供对"==","!="运算符的重载。

2. `dynamic_cast`动态类型转换
- 用于在具有多态继承关机的父子类指针和引用之间进行的显式转换。并会检查目标对象和期望转换
  的对象是否一致，如果一致则转换成功，否则转换失败。
- 如果转换的是指针，返回NULL表示失败，指针在转换失败时不会抛出异常；如果是转换的是引用抛
  出异常`"bad_cast"`表示失败。
- 动态类型转换 提高了安全性。


#异常exception
##1. 什么叫错误？
语法错误: 程序员在编码阶段
逻辑错误: 程序员要借助调试工具诊断并修改
功能错误: 程序员修改代码
设计缺陷: 设计员修改设计，程序员需要重新编码。
需求不符: 分析员修改需求，设计员调整设计
环境异常: 客服协助用户调整运行环境
操作不当: 客服指导用户按照正确的方法使用

##2. 错误处理机制
1. 通过返回值表示错误
缺点: 错误处理流程比较复杂，需要逐层判断，代码臃肿
优点: 函数调用路径中所有的局部对象都能被右花括号正确的析构，不会出现内存泄露。
2. 通过远跳处理错误
 `#include<setjmp>` // 
 long jump
缺点: 函数调用路径中的局部对象失去析构的机会，形成内存的泄露。
有点: 不需要逐层判断。一步到位，处理错误，代码精炼。
3. C++异常
结合两种传统错误处理方式的优点，在代码的形式上实现了一步到位的错误处理，同时又能保证所有
的局部对象得到正确的析构。

##3. 异常语法
3.1 异常抛出
throw 
1)可以抛出一本类型的异常
throw -1；
throw "打开文件失败"

2)可以抛出类类型的异常
throw FileException("打开文件失败");

3.2 异常捕获
try{
    可能引发异常的操作。
}
catch(异常类型1& ex){

}
catch(...){

}


