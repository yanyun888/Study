
day06
close 函数

第二个参数针对的是文件描述符，第三个参数针对的是文件的存储权限


#include<unistd.h>
int close(int fd);

关闭参数指定的文件描述符


#include<unistd.h>

ssize_t read(int fd,void* buf,size_t count);
count为希望尝试读取数据的大小
返回值:成功返回读取到数据的大小，遇到文件末尾返回0，失败返回-1

ssize_t write(int fd,const void *buf,size_t count);
buf缓冲区首地址
用于将缓冲区的数据写到文件中

函数read/write函数本身就是以二进制形式进行读写操作的，所以对二进制文件的读写操作不需要进行特殊处理

off_t lseek(int fd,off_t offset,int whence);
offset的单位是字节
用于手动调整文件的读写位置
SEEK_END-文件末尾--最后一个字符的下一个位置

'a' 97
'A' 65
'0' 48
'\n' 10
空格 32

文件的空洞，当文件的写位置移动到SEEK_END后面再写入数据时，数据也是可以写入的，
只是中间有一块区域空闲，该区域叫做文件的空洞现象。
该区域会计算到文件的大小中，但没有有效数据，获取时会得到\0

标C/UC文件操作的比较
标C的文件操作函数比UC的文件操作函数效率高一些，因为标C文件操作的内部提供了输入输出缓存区，
当数据积累到一定数量时才会访问内核，将数据写入到文件中。


使用time命令获取当前程序的运行时间
命令的执行结果如下
real--  真实的执行时间
user--	用户态时间
sys--	内核态时间

对UC的文件操作函数，可以通过自定义缓存区的方式来提高效率，但是并不一定是缓存区越大效率越高。


文件的内核结构/文件描述符的工作原理

文件描述符->文件表指针->文件表结构->v节点->c磁盘

文件描述符本质上是一个整数，但是文件的相关信息并不是存放在文件描述符中，而是存放在文件表的数据
结构中，使用open函数打开文件时，会将文件的相关信息加载到文件表等数据结构中，但是出于安全和效率
等方面的考虑，文件表并不适合直接操作，而是给文件表等结构做一个编号，拿编号进行操作。

在每一个进程的内部，都会维护一张文件描述符的总表，当有文件描述符需求时，会去查找最小的未被使
用的文件描述符返回，文件描述符号虽然是int类型，但是本质上是非负数(从0开始)。
0 1 2 被系统占用--stdin,stdout,stderr。一般用户的文件从3开始使用，文件描述符号可以到OPEN_MAX
linux系统一般是到255，当前ubuntu最大支持1024

我们使用close关闭文件时，本质上是将文件描述符和文件表的对应关系从文件描述符总表中移除，并不一
定会删除文件表，只有当文件表没有和任何其他描述符相对应是(就是一个文件表可以对应多个文件描述符
号),才会删除文件表。close函数并不会改变文件描述符号的整数值，仅会使文件描述符的映射关系失效。


fcntl



