#复习
##模板起源
源自类型的约束
带参数宏定义
通过宏定义实现通用框架，预处理拓展出具体实现
定义模板，编译器将模板结合具体类型，实例化为具体函数或类。
##函数模板
定义:
使用:
隐式推断：
二次编译：
重载：越具体越优先 + 越匹配越优先
##类模板
在成员变量、成员函数、基类、内部类型中使用参数化类型定义
定义：
使用：
类模板不能隐式推断
两步实例化：类模板-(编译器实例化)->类-(处理器实例化)->对象
静态成员变量：定义、作用域
递归实例化：用一个类模板的实例化类 来 实例化该模板自身。

类模板的特化：用针对特殊的类型特殊实现弥补通用实现的不足
全类特化和成员特化：
类模板的局部特化：只针对部分类型参数取某些特殊类型，或者针对类型参数间某种关系，再或者针对某些特殊属性所做的特化
局部特化只能通过全类特化
智能指针：原理、`<memory>`,`auto_ptr<T>`
模板的缺省参数：靠后、向前引用，函数模板在C++98中不能使用缺省参数，但是在C++11中可以。
` GCC < 4.8 ` : `-std=c++0x`
` GCC >= 4.8` : `-std=c++11`
隐式推断的优先级要高于缺省参数。


#新内容
##模板的非类型参数
为模板的非类型参数所传递的实参，可以是常量、常量表达式，或带有常属性(const,C限定)的变量，但是不能同时带有挥发性(volatile,V限定)

模板的非类型参数不能选择浮点类型和类类型


##typename关键字
1. 声明模板的类型参数
`template<typename T> ...` 等价于 `template<class T> ...`
2. 识别嵌套依赖
在模板中要依赖于类型参数的内部类型，这种情况必须通过typename关键字帮助编译器正确识别所引用的内部类型
class    - 声明类         
         + 模板的类型参数
typename - 识别嵌套依赖
无论是声明模板的类型参数，还是解决嵌套依赖
##template关键字
1. 声明模板
`template<... > ...`
2. 识别嵌套模板
在模板中依赖于类型参数的内部模板，这种情况下必须通过template关键字棒喝足编译器正确识别所用模板

##子模板访问基模板
在继承语法中，编译器对于子类中引用标识符的名字搜索顺序是：
成员函数局部作用域->子类作用域->基类作用域->...->全局作用域，但是如果基类是一个类模板，在第一次编译时时，
因为类型参数所表示的具体类型尚不明确，这是编译器就会跳过基类的作用域，为了保证名字搜索顺序不变，就需要在所
引用的基类表示符前面显示加上作用域限定，或者显示使用this指针。

##模板形式的模板成员
1. 模板形式的成员变量
基于类模板的类型参数所实例化的另一个类模板得到的类型定义的成员变量。
2. 模板形式的成员函数
类模板的成员函数需要使用独立于类模板类型参数以外的类型参数
3. 模板形式的成员类型
类模板的成员类本身又是一个类模板，而且需要使用独立于歪成类型模板类型参数以外的类型参数

##模板形式的模板参数
如果一个类模板的模板参数所结合的实参并非具体类型，而是另一个类模板，那么该参数就不能通过typename关键字声明
而应采用如下形式：
`template<模板形参表> class 模板参数名`
如果在类模板的实现中并不需要引用模板形参名则可以将参数名称省略不写。

##零初始化
缺省情况下，编译器对与基本类型的局部变量和成员变量不做初始化，而对于类类型的局部变量和成员变量会通过构造函数
初始化，如果在模板中一类型参数的形式表现不同的数据类型，有可能因为初始化策略的不同而导致结果的不一致。
为此，可以显示指定对通过参数化类型定义的变量采用零初始化，对于类类型会调用缺省构造函数初始化，而对于基本类型，
则采相应类型的零初始化。

##模板中的虚函数
1. 类模板中可以定义虚函数，而且和普通类一样，只要满足有效的覆盖的条件，就能够表现出多态性。
2. 虚函数不能同时又是模板函数。基于虚函数的多态机制，需要一个名为虚函数表的函数指针数组，该数组在类被编译或类
模板被实例化的过程中产生，而此时那些模板形式的成员函数未被实例化，其入口地址和重载版本的个数，要等到编译器处理
完对该函数的所有调用以后才能确定。成员函数模板的延迟编译阻碍了虚函数表的静态构建。**(虚函数表是整个类共享的)**

##编译模型
单独编译在处理模板的时候所处理的问题
nm命令查看.o文件的
1. 分离模型：将模板的声明、实现和使用分别放在不同的文件中。编译对每个源文件都是单独编译的，因此当编译器编译模
板的实现文件时，所生成的内部表示，在其编译使用模板的编译单元时已经不复存在了，模板失去了被第二次编译的机会，其
实例化代码在目标模块中并不存在，最终导致链接失败。
2. 包含模型：不在模板的实现文件开始处包含其声明文件，而在该模板声明文件的结尾处包含其实现文件，实例化该模板的
代码只要包含了对模板的声明就等于也包含了他们的实现，这样就把模板的声明、实现和实例化强制在一个编译单元中，保证
模板总能得到正确的实例化，链接成功。
缺点：延长总体编译时间，实现代码必须公开。
3. 显示实例化：在模板的是实现文件中通过template关键字显示地用 用户 可能用的类型实例化函数和类模板为具体的函数
和类，以保证在模板的实现中就已经包含了二进制指令代码，可以链接成功。
优点：缩短总体编译时间、实现代码不公开。
缺点：用于显式实例化模板的类型是有限的，不适用于通用化的模板。
4. 导出模型：在模板声明时于template关键字前面加上export关键字，即表示该模板为导出。编译器对于道出模板的内部表
示会做持久性缓存，以保证实例化该模板的文件被编译时，其内部表示依然可以被引用，链接成功。
缺点：大多数编译器并不支持export关键字。
在C++2011已经将export关键字挪做他用。

**？标准模板库大多使用的是包含模式**

##预编译头文件
```
comm.h
 #include <stdio.h>
 #include <sys/socket.h>
 #include<iostream>
 using namespace std;
```
使用时
g++ -c comm.h -> .h.gch   (GNU compile headerfile)

>a.cpp
>`#include"comm.h"  // 直接载入comm.h.gch`
>b.cpp
>` #include"comm.h"`


windows 平台的解决方案
```
stdafx.h
stdafx.cpp     编译成->      <项目>.pch (pre compile headerfile)
 #include "stdafx.h"
```














